---
ERC: "5559"
TITLE: "Cross-Chain Write Deferral Protocol"
DESCRIPTION: Cross-chain write deferral protocol incorporating secure write deferrals to L2s and centralised databases
AUTHOR: (@sshmatrix), (@0xc0de4c0ffee), (@arachnid)
DISCUSSIONS-TO: ◥
STATUS: Draft
TYPE: Standards Track
CATEGORY: ERC
CREATED: ◥
REQUIRES: ◥ 
---

## Abstract
The cross-chain write deferral protocol, CCIP-Write in short, is designed to replace Ethereum L1 storage with L2 chains and/or centralised databases, with an aim to cut gas costs and further privacy while retaining the secure aspects of on-chain storage. Methods in this document specifically target security and verifiability of write deferrals; the cross-chain data written with these methods can then be retrieved by EIP-3668-compliant contracts completing the cross-chain data life cycle. This document, alongside EIP-3668, is a meaningful step toward a secure infrastructure for cross-chain write deferrals and data retrievals.

## Motivation
EIP-3668, or 'CCIP-Read' in short, has been key to retrieving cross-chain data for a variety of contracts on Ethereum blockchain, ranging from price feeds for DeFi contracts, to more recently records for ENS users. The latter case dedicatedly uses cross-chain storage to bypass the usually high gas fees associated with on-chain storage; this aspect has a plethora of use cases well beyond ENS records and a potential for significant impact on universal affordability and accessibility of Ethereum. 

Cross-chain data retrieval through EIP-3668 is a relatively simpler task since it assumes that all relevant data originating from cross-chain storages is translated by CCIP-Read-compliant HTTP gateways; this includes L2 chains and centralised databases (or decentralised storages; although not covered under this draft). On the flip side however, so far each service leveraging CCIP-Read must handle writing this data securely to these storage types on their own, while also incorporating reasonable security measures in their CCIP-Read compatible contracts for verifying this data on L1. While these security measures are in-built into L2 architectures, database storage providers on the other hand, must incorporate some form of explicit security measures during write operations so that cross-chain data's integrity can be verified by CCIP-Read contracts during data retrieval stage.

EIP-5559 is the first step toward such a tolerant 'CCIP-Write' protocol which outlines how secure write deferrals can be made to L2 and centralised databases. The cases of L2 and database are similar; deferral to an L2 involves routing the `eth_call` to L2, while deferral to a database can be made by extracting `eth_sign` from `eth_call` and posting the resulting signature along with the data for later verification. This proposal completely. This document also enables more complex and generic use-cases of databases such as those protocols which do not store the signers' addressess on L1.

## Specification
### Overview
The following specification revolves around the structure and description of a cross-chain storage handler tasked with the responsibility of writing to L2 or database storage. This draft introduces `StorageHandledByL2()` and `StorageHandledByDatabase()` storage handlers, and proposes that new `StorageHandledBy__()` reverts be allowed through new EIPs that sufficiently detail their interfaces and designs. Some foreseen examples of new storage handlers include `StorageHandledBySolana()` for Solana, `StorageHandledByFilecoin()` for Filecoin, `StorageHandledByIPFS()` for IPFS, `StorageHandledByIPNS()` for IPNS, `StorageHandledByArweave()` for Arweave, `StorageHandledByArNS()` for ArNS, `StorageHandledBySwarm()` for Swarm etc.

![](https://raw.githubusercontent.com/namesys-eth/namesys-ccip-write/main/images/schematic.png)

### L2 Handler: `StorageHandledByL2()`
A minimal L2 handler only requires the list of `chainId` values and the corresponding `contract` addresses, although additional measures must be taken to ensure that the integrity of calldata is maintained by the client before the call is routed to L2. Therefore, this proposal formalises that

1. The storage handler must contain a `proof` of the original calldata. This `proof` is simply

    ```solidity
    // Proof is hash of concatenated calldata
    bytes32 proof = keccak256(
        abi.encodePacked(
            bytes32 node,
            bytes32 key,
            bytes32 value
        )
    )
    ```

    for any generic function `function setValue(bytes32 node, bytes32 key, bytes32 value) external` in the L1 contract.

2. The L2 contract must implement `function setValueWithProof(bytes32 node, bytes32 key, bytes32 value, bytes32 proof) external`

3. The deferral in this case must prompt the client to build the transaction with original calldata and the proof, and submit it to the L2 by calling the `setValueWithProof()` function.

4. The `setValueWithProof()` function must internally calculate the proof, match it with the proof provided by the client and revert if the proofs do not match.
 
One example construction of an L2 handler in an L1 contract is given below.

#### L1
```solidity
// Define revert event
error StorageHandledByL2(
    address contractL2, 
    uint256 chainId, 
    bytes32 proof
);

// Generic function in a contract
function setValue(
    bytes32 node,
    bytes32 key,
    bytes32 value
) external {
    // Get metadata from on-chain sources
    (
        address contractL2, // Contract address on L2
        uint256 chainId // L2 ChainID
    ) = getMetadata(node); // Arbitrary code
    // contract = 0x32f94e75cde5fa48b6469323742e6004d701409b
    // chainId = 21
    bytes32 proof = keccak256(
        abi.encodePacked(
            bytes32 node,
            bytes32 key,
            bytes32 value
        )
    )
    // Defer write call to off-chain handler
    revert StorageHandledByL2( 
        contractL2,
        chainId,
        proof
    );
};
```

#### L2
```solidity
// Function in L2 contract
function setValueWithProof(
    bytes32 node,
    bytes32 key,
    bytes32 value,
    bytes32 proof
) external {
    // Calculate proof
    bytes32 _proof_ = keccak256(
        abi.encodePacked(
            bytes32 node,
            bytes32 key,
            bytes32 value
        )
    )
    // Verify integrity of calldata
    require(_proof_ === proof, "BAD_PROOF");
    ... // Rest of the code
}
```

### Database Handler: `StorageHandledByDatabase()`
A minimal database handler is similar to an L2 in the sense that:

  a) similar to `chainId`, it requires the `gatewayUrl` that is tasked with handling off-chain write operations, and

  b) similar to `eth_call`, it must require `eth_sign` output to secure the data, and the client must prompt the users for these signatures.

In this case, the `metadata` must contain the bespoke `gatewayUrl` and may additionally contain the addresses of `dataSigner` of `eth_sign`. If a `dataSigner` is included in the metadata, then the client must make sure that the signature forwarded to the gateway is signed by that `dataSigner`. It is possible for the `dataSigner` to exist off-chain instead and not be returned in the metadata; for this scenario, refer to additional details in section 'Off-Chain Signers'. One example construction of a database handler's `metadata` is given below.

```solidity
error StorageHandledByDatabase(address sender, bytes callData, bytes metadata);

(
    string gatewayUrl, // Gateway URL
    address dataSigner // Ethereum signer's address; must be address(0) for off-chain signer
) = getMetadata(node);
// gatewayUrl = "https://api.namesys.xyz"
// dataSigner = 0xc0ffee254729296a45a3885639AC7E10F9d54979
bytes metadata = abi.encode(gatewayUrl, dataSigner);
bytes callData = abi.encode(node, key, value);
address sender = msg.sender;
```

In the above example, the client must first verify that the `eth_sign` is signed by a matching `dataSigner`, then prompt the user for a signature and finally pass the resulting signature to the `gatewayUrl` along with the off-chain data. The message payload for this signature must be formatted according to the directions in the 'Data Signatures' section further down this document. The off-chain data and the signatures must be encoded according to the directions in the 'CCIP-Read Compatiable Payload' section. Further directions for precise handling of the message payloads and metadata for databases are provided in 'Interpreting Metadata' section.

### Interpreting Metadata
The following section describes the precise interpretation of the metadata common to both IPNS and database storage handlers. The methods described in this section have been designed with autonomy, privacy, UI/UX and accessibility for ethereum users in mind. The plethora of off-chain storages have their own diverse ecosystems such that it in not uncommon for each storage to have its own set of UI/UX requirements, such as wallets, signer extensions etc. If ethereum users were to utilise such storage providers, they will inevitably be subjected to additional wallet extensions in their browsers. This is not ideal and the methods in this section have been crafted such that users do not need to install any additional UI/UX components or extensions other than their favourite ethereum wallet. 

`StorageHandledByIPNS()` is more complex in construction than `StorageHandledByDatabase()` which is a reduced version of the former. For this reason, we still start by describing how clients must implement `StorageHandledByIPNS()` first. Later on, we will reduce the requirements to the simpler case of `StorageHandledByDatabase()`.

#### Key Generation
This draft proposes that both the `dataSigner` and `ipnsSigner` keypairs be generated deterministically from ethereum wallet signatures; see figure below.

![](https://raw.githubusercontent.com/namesys-eth/namesys-ccip-write/main/images/keygen.png)

This process involving deterministic key generation can be implemented concisely in a single unified `keygen()` function as follows.

```js
/* Pseudo-code for key generation */
function keygen(
  username, // Key identifier
  caip10, // CAIP identifier for the blockchain account
  signature, // Deterministic signature from wallet
  password // Optional password
) {
  // Calculate input key by hashing signature bytes using SHA256 algorithm
  let inputKey = sha256(signature);
  // Calculate info from CAIP-10 identifier and username
  let info = `${caip10}:${username}`;
  // Calculate salt for keygen by hashing concatenated info, hashed password and hex-encoded signature using SHA256 algorithm
  let salt = sha256(`${info}:${sha256(password || "")}:${signature}`);
  // Calculate hash key output by feeding input key, salt & info to the HMAC-based key derivation function (HKDF) with dLen = 42
  let hashKey = hkdf(sha256, inputKey, salt, info, 42);
  // Calculate and return both ed25519 and secp256k1 keypairs
  return [
    ed25519(hashKey), // Calculate ed25519 keypair from hash key
    secp256k1(hashKey) // Calculate secp256k1 keypair from hash key
  ]
}
```

This `keygen()` function requires four variables: `caip10`, `username`, `password` and `signature`. Their descriptions are given below.

##### 1. `caip10`
CAIP-10 identifier `caip10` is auto-derived from the connected wallet's checksummed address `wallet` and `chainId`.

```js
/* CAIP-10 identifier */
const caip10 = `eip155:${chainId}:${wallet}`
```

##### 2. `username`
`username` may be prompted from the user by the client or determined by the protocol. This public field allows users to switch their protocol-specific IPNS namespace in the future. For instance, protocols may set `username` deterministically as equal to `caip10` or some protocol-specific function of `node`; see example below.

```js
/* Username is dependent on the storage type which can be 'walletType' or 'nodeType'. See definitions at the end of this section */
// Example: node = namehash(normalise(ens)) for ENS, aka preimage(node) = ens
let username;
if (storage === 'walletType') username = caip10;
if (storage === 'nodeType') username = preimage(node);
```

##### 3. `password`
`password` is an optional private field and it must be prompted from the user by the client; this field allows users to secure their IPNS namespace for a given `username`.
```js
/* IPNS secret key identifier */ 
// Clients must prompt the user for this
const password = 'key1'
```

##### 4. `signature`
Deterministic signature forms the backbone of secure, keyless, autonomous and smooth UI when off-chain storages are in the mix. In the simplest implementation, one such signature must be prompted from the users by the clients. `sigKeygen` is the deterministic ethereum signature responsible for 

- the IPNS key generation and for interpreting `ipnsSigner` metadata, and
- the delegated signer key generation and for interpreting `dataSigner` metadata. 

In order to enable batch data writing for multiple nodes, a delegated signer must be derived from the owner or manager keys of a node. Message payload for `sigKeygen` must be formatted as:

```text
Requesting Signature To Generate Keypair(s)\n\nOrigin: ${username}\nProtocol: ${protocol}\nExtradata: ${extradata}\nSigned By: ${caip10}
```

where the `extradata` is calculated as follows,

```solidity
// Calculating extradata in keygen signatures
bytes32 extradata = keccak256(
    abi.encodePacked(
        pbkdf2(
            password, 
            salt, 
            iterations
        ), // Stretch password with PBKDF2
        wallet
    )
)
```

where `PBKDF2` - with `keccak256(abi.encodePacked(username))` as salt and last 5 hex-nibbles converted to `uint` as the iteration count - is used for brute-force vulnerability protection.

```js
/* Definitions of salt and iterations in PBKDF2 */
let salt = keccak256(abi.encodePacked(username));
let iterations = uint(salt.slice(-5)); // max(iterations) = uint(0xFFFFF) = 1048757
```

The remaining `protocol` field is a protocol-specific identifier limiting the scope to a specific protocol. This identifier cannot be global and must be uniquely defined by each implementation or protocol. With this deterministic format for signature message payload, the client must prompt the user for `eth_sign` signature. Once the user signs the messages, the `keygen()` function can derive the IPNS keypair and the signer keypair. The clients must additionally derive the IPNS CID and ethereum address corresponding to the IPNS and signer public keys. The metadata interpretation concludes with the client ensuring that 

- the derived IPNS CID must match the `ipnsSigner` metadata, and
- the derived signer's address must match the `dataSigner` metadata.

If these conditions are not met, clients must throw an error and inform the user of failure in interpretation of the metadata. If these conditions are met, then the client has the correct private keys to update a user's IPNS record as well as sign a user's data for later verification by CCIP-Read. Since the derived signer can sign multiple instances of off-chain data in the background without prompting the user, it is possible to update data for multiple nodes simultaneously with this method.

#### Storage Types
Storage types refer to two types of IPNS namespaces that can host a user's data. In the first case of `nodeType`, each `node` has a unique IPNS container whose CID is stored in `ipnsSigner` metadata. In the second case of `walletType`, a user can store the data for all nodes owned or managed by a given wallet. Naturally, the second method is highly cost effective although it compromises on security to some extent; this is due to a single IPNS signer manifesting as a single point of compromise for all off-chain data for a wallet. This feature is achieved by choosing an appropriate `username` in the signature message payload of `sigKeygen` depending on the desired storage type.

During the initialisation step when the user sets on-chain `ipnsSigner` for the first time, the clients must prompt the user for their choice of storage type. Depending on the user's choice, IPNS CID can be posted on chain with an appropriate index.

```js
/* Setting IPNS signer on-chain during initialisation setup */
// IPNS signer derived from keygen() in CIDv1 format
let cid = 'bafyreibcli3vlmr4et6oekv3xdjx2sm6k4tioynbavmwgrsevklujpzywu';
// IPNS signer is function of node for 'nodeType' storage; remove constant 'e5010172002408011220' prefix from hex-encoded payload to save gas
if (storage === 'nodeType') setIpnsSigner(node, cid.encode('hex').replace('e5010172002408011220', ''));
// IPNS signer is function of wallet for 'walletType' storage; remove constant 'e5010172002408011220' prefix from hex-encoded payload to save gas
if (storage === 'walletType') setIpnsSigner(bytes32(uint256(uint160(wallet))), cid.encode('hex').replace('e5010172002408011220', ''));
```

CCIP-Write-enabled contracts should implement an appropriate internal mechanism for fetching IPNS signer as a function of `node` or `wallet`. This mechanism must follow the previously mentioned fallback strategy: the contract must first check if `nodeType` storage exists for a given `node`, and if no `ipnsSigner` exists for a `node`, then the contract should check for fallback `walletType` storage for a `wallet` and return the result in the revert.

### Revert `StorageHandledByDatabase()`
The case of `StorageHandledByDatabase()` handler is a subset of the decentralised storage handler, in the sense that the clients should simply skip interpreting IPNS related metadata. There is additionally no concept of storage types for off-chain database handlers. Other than that, the entire process is the same as `StorageHandledByIPNS()`.
 
### Off-Chain Signers
It is possible to further save on gas costs by not storing the `dataSigner` metadata on chain. In detail, instead of storing the `dataSigner` on chain for verification, clients can provide the user with the option to,

- request an approval for an off-chain `dataSigner` signed by the owner or manager of a node, and
- post this approval and the off-chain `dataSigner` along with the off-chain data in encoded form.

CCIP-Read-enabled contracts can then verify during resolution time that the approval attached with the data comes from the node's manager or owner and that it approves the expected `dataSigner`. Using this mechanism of delegating signatures to an off-chain signer, no on-chain `dataSigner` needs to be posted. This additional saving comes at the cost of one additional approval signature `approval` that the clients must prompt from the user. This signature must have the following message payload format:

```text
Requesting Signature To Approve Data Signer\n\nOrigin: ${username}\nApproved Signer: ${dataSigner}\nApproved By: ${caip10}
```

where `dataSigner` must be checksummed.

### Data Signatures
Signature(s) `sigData` accompanying the off-chain data must implement the following format in their message payloads:  

```text
Requesting Signature To Update Off-Chain Data\n\nOrigin: ${username}\nData Type: ${dataType}\nData Value: ${dataValue}
```

where `dataType` parameters are protocol-specific; they are defined in ENSIP-5, ENSIP-7 and ENSIP-9 for ENS (formerly EIP-634, EIP-1577 and EIP-2308 respectively), e.g. `text/avatar`, `address/60` etc.

### CCIP-Read Compatible Payload
The final EIP-3668-compatible `data` payload in the off-chain data file must then follow this format,

```solidity
bytes encodedData = abi.encode(['bytes'], [dataValue])
bytes dataPayload = abi.encode(
    ['address', 'bytes32', 'bytes32', 'bytes'],
    [dataSigner, sigData, approval, encodedData]
)
```

which the CCIP-Read-enabled contracts must first correctly decode, and then verify signer approval and data signatures, before resolving the data value. The client must construct this `data` and pass it to the gateway in the `POST` request along with the raw values for indexing.

### `POST` & Protocol-specific Parameters
For any storage other than a blockchain with a wallet extension, the client must call the `gatewayUrl` via a `POST` request. The structure of the `POST` is protocol-specific and left up to individual protocols to handle internally. Besides the `POST` request, `username`, `protocol` and `dataType` are the other protocol-specific parameters that we have encountered in the text before. Note that we didn't yet define the paths for the off-chain data files either, i.e. where should the file containing off-chain `data` be stored and later referred to in CCIP-Read-compatible contracts? These `path` schemes are also native to each implementation and are therefore left up to each protocol to define along with the previously mentioned parameters. The combined total of five parameters should be defined by the protocols through a native improvement proposal. For example, `POST` format, `username`, `protocol`, `dataType`, and `path` for ENS are described in ENSIP-19. 

### New Revert Events
1. Each new storage handler must submit their `StorageHandledBy__()` identifier through an ERC track proposal referencing the current draft and EIP-5559.

2. Each `StorageHandledBy__()` provider must be supported with detailed documentation of its structure and the necessary `metadata` that its implementers must return.

3. Each `StorageHandledBy__()` proposal must define the precise formatting of any message payloads that require signatures and complete descriptions of custom cryptographic techniques implemented for additional security, accessibility or privacy.

## Implementation featuring ENS
ENS off-chain resolvers capable of reading from and writing to decentralised storages are perhaps the most complex use-case for CCIP-Read and CCIP-Write. One example of such a (minimal) resolver is given below along with the client-side code for handling the revert.

### Contract
```solidity
/* ENS resolver implementing StorageHandledByIPNS() */
interface iResolver {
    // Defined in EIP-5559
    error StorageHandledByIPNS(
        address sender,
        bytes callData,
        bytes metadata
    );
    // Defined in EIP-137
    function setAddr(bytes32 node, address addr) external;
}

// Defined in EIP-5559
string public gatewayUrl = "https://post.namesys.xyz"; // RESTful API endpoint
string public metadataUrl = "https://gql.namesys.xyz"; // GQL API endpoint

/**
* Sets the ethereum address associated with an ENS node
* [!] May only be called by the owner or manager of that node in ENS registry
* @param node Namehash of ENS domain to update
* @param addr Ethereum address to set
*/
function setAddr(
    bytes32 node,
    address addr
) authorised(node) {
    // Get ethereum signer & IPNS CID stored on-chain with arbitrary logic/code
    // Both may be unique to each name, or each owner or manager address
    (address dataSigner, bytes ipnsSigner) = getMetadata(node); 
    // Construct metadata required by off-chain clients. Clients must refer to ENSIP-19 for directions to interpret this metadata
    bytes memory metadata = abi.encode(
        gatewayUrl, // Gateway URL tasked with writing to IPNS
        dataSigner, // Ethereum signer's address
        ipnsSigner, // IPNS signer's hex-encoded CID as context for namespace
        metadataUrl // GraphQL endpoint for encoded version (per ENSIP-16)
    )
    // Defer to IPNS storage
    revert StorageHandledByIPNS(
        msg.sender,
        abi.encode(node, addr),
        metadata
    );
}
```

### Client-side
```js
/* Client-side pseudo-code in ENS App */
// IPNS publishing provider
import IPNS from provider;
// Decode calldata from revert
const [node, addr] = abi.decode(callData);
// Decode metadata from revert
const [gatewayUrl, dataSigner, ipnsSigner, metadataUrl] = abi.decode(metadata);
// Fetch last IPNS version data from metadata API endpoint
let version = await fetch(metadataUrl, node);
// Deterministically generate IPNS and signer keypairs
let [ipnsKey, signerKey] = keygen(username, caip10, sigKeygen, password);
// Check if generated IPNS and signer public keys match the metadata
if (ipnsKey.pub === ipnsSigner && signerKey.pub === dataSigner) {
    // Sign the data with signer private key
    let signedData = await signData(node, addr, signerKey.priv);
    // Make IPFS content from signed data
    let ipfsCid = makeIpfs(signedData);
    // Create IPNS revision to publish from version data
    let revision = IPNS.v0(ipfsCid) || IPNS.increment(version, ipfsCid);
    // Publish revision to IPFS network
    await IPNS.publish(gatewayUrl, revision, signedData, ipnsKey.priv);
} else {
    // Tell user that derived keypairs did not match metadata
    throw Error('Bad Credentials');
}
```

## Backwards Compatibility
Methods in this document are not compatible with previous EIP-5559 specifications.

## Security Considerations
1. Since both the `ed25519` and `secp256k1` private keys for IPNS and delegated signer respectively are derived from the same `signature` and `hashKey`, leaking one key is equivalent to leaking the other. 

2. Clients must purge the derived IPNS and signer private keys from local storage immediately after signing the IPNS update and off-chain data respectively.

3. Signature message payload and the resulting deterministic signature `sigKeygen` must be treated as a secret by the clients and immediately purged from local storage after usage in the `keygen()` function.

4. Clients must immediately purge the `password` from local storage after usage in the `keygen()` function.

## Copyright
Copyright and related rights waived via [`CC0`](../LICENSE.md).